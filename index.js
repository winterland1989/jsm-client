// Generated by CoffeeScript 1.9.3
(function() {
  var CONFIG_FILE_NAME, DEFAULT_REPOSITORY, configFile, extMap, fs, getExt, home, http, install, parseEntry, path, querystring, url;

  path = require('path');

  http = require('http');

  querystring = require('querystring');

  url = require('url');

  fs = require('fs-extra');

  CONFIG_FILE_NAME = '.jsm.json';

  DEFAULT_REPOSITORY = 'http://jsm.winterland.me';

  home = process.env[process.platform === 'win32' ? 'USERPROFILE' : 'HOME'];

  configFile = path.join(home, CONFIG_FILE_NAME);

  extMap = {
    '.ls': 'livescript',
    '.coffee': 'coffeescript',
    '.js': 'javascript',
    '': void 0
  };

  getExt = function(language) {
    var ext, lan;
    for (ext in extMap) {
      lan = extMap[ext];
      if (lan === language) {
        return ext;
      }
    }
    return '';
  };

  module.exports = {
    readJsmClientConfig: function() {
      var conf, f;
      if (fs.existsSync(configFile)) {
        f = fs.readFileSync(configFile, {
          encoding: 'utf8'
        });
        conf = JSON.parse(f);
        if (conf.repository && conf.username && conf.password) {
          return conf;
        } else {
          throw new Error("remove " + configFile + " and restart...");
        }
      } else {
        return {
          repository: DEFAULT_REPOSITORY,
          username: '',
          pwdHash: ''
        };
      }
    },
    writeJsmClientConfig: function(conf) {
      var f;
      return f = fs.writeFileSync(configFile, JSON.stringify(conf), {
        encoding: 'utf8'
      });
    },
    parseEntry: parseEntry = function(filePath) {
      var author, base, ext, title, titleMatch, version, versionMatch;
      filePath = path.normalize(filePath);
      ext = path.extname(filePath);
      base = path.basename(filePath, ext);
      author = path.basename(path.dirname(filePath));
      titleMatch = base.match(/^([a-zA-Z]+)/g);
      title = (function() {
        if (titleMatch != null) {
          return titleMatch[0];
        } else {
          throw new Error("Parse entry name failed: " + filePath);
        }
      })();
      versionMatch = base.match(/([0-9]+)$/g);
      version = versionMatch != null ? parseInt(versionMatch[0]) : 0;
      return {
        title: title,
        version: version,
        author: author,
        language: extMap[ext]
      };
    },
    publish: function(conf, entry) {
      var chunks, hostname, port, postData, ref, req;
      entry.pwdHash = conf.pwdHash;
      postData = querystring.stringify(entry);
      ref = url.parse(conf.repository), hostname = ref.hostname, port = ref.port;
      chunks = [];
      req = http.request({
        hostname: hostname,
        port: port,
        path: '/snippet',
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          'Content-Length': postData.length
        }
      }, function(res) {
        res.on('data', function(data) {
          return chunks.push(data);
        });
        return res.on('end', function() {
          var e, snippet;
          try {
            snippet = JSON.parse(Buffer.concat(chunks).toString('utf8'));
            return console.log(snippet.author + "/" + (snippet.title + snippet.version) + " (revision" + snippet.revision + ") published succeessful!");
          } catch (_error) {
            e = _error;
            return console.log("publish failed!");
          }
        });
      });
      req.on('error', function(error) {
        console.log('Publish failed!:');
        return console.log(error);
      });
      req.write(postData);
      return req.end();
    },
    install: install = function(conf, entry) {
      var entryContent, entryDir, filePath, i, len, requires, results;
      entryDir = path.dirname(entry);
      entryContent = '';
      requires = [];
      try {
        entryContent = fs.readFileSync(entry, 'utf8');
      } catch (_error) {}
      switch (extMap[path.extname(entry)]) {
        case 'javascript':
          entryContent.replace(/\brequire\s*\(\s*(["'])([^"'\s\)]+)\1\s*\)/g, function(match, quote, path) {
            requires.push(path);
            return match;
          });
          break;
        case 'coffeescript':
          entryContent.replace(/\brequire\s*(["'])([^"'\s\)]+)\1\s*/g, function(match, quote, path) {
            requires.push(path);
            return match;
          });
          break;
        case 'livescript':
          entryContent.replace(/\brequire[!?]\s*(["'])([^"'\s\)]+)\1\s*/g, function(match, quote, path) {
            requires.push(path);
            return match;
          });
      }
      results = [];
      for (i = 0, len = requires.length; i < len; i++) {
        filePath = requires[i];
        results.push((function(filePath) {
          var chunks, e, entryObj, ext, hostname, index, lan, port, ref, req, results1, succ;
          if ((index = filePath.indexOf('jsm')) !== -1) {
            entryObj = parseEntry(path.resolve(entryDir, filePath.slice(index + 4)));
            filePath = path.resolve(entryDir, filePath);
            chunks = [];
            if ((entryObj.author != null) && (entryObj.title != null) && (entryObj.version != null)) {
              delete entryObj.language;
              ref = url.parse(conf.repository), hostname = ref.hostname, port = ref.port;
              req = http.request({
                hostname: hostname,
                port: port,
                path: '/snippet?' + querystring.stringify(entryObj),
                method: 'GET'
              }, function(res) {
                res.on('data', function(data) {
                  return chunks.push(data);
                });
                return res.on('end', function() {
                  var e, mtime, snippet;
                  if (res.statusCode === 200) {
                    try {
                      snippet = JSON.parse(Buffer.concat(chunks).toString('utf8'));
                      if ((path.extname(filePath)) === '') {
                        filePath += getExt(snippet.language);
                      }
                      fs.ensureFileSync(filePath);
                      fs.writeFileSync(filePath, snippet.content);
                      mtime = new Date(snippet.mtime);
                      fs.utimesSync(filePath, mtime, mtime);
                      install(conf, filePath);
                      return console.log('Installing snippet: ' + filePath + ' succeessfully');
                    } catch (_error) {
                      e = _error;
                      return console.log("Write snippet failed: " + filePath);
                    }
                  } else {
                    console.log(res.statusCode);
                    return console.log("Download snippet failed: " + filePath);
                  }
                });
              });
              req.on('error', function(error) {
                console.log('Get snippet failed:' + filePath);
                return console.log(error);
              });
              return req.end();
            } else {
              console.log(entry);
              return console.log("Parse entry name failed: " + filePath);
            }
          } else {
            filePath = path.resolve(entryDir, filePath);
            if ((path.extname(filePath)) === '') {
              succ = 0;
              results1 = [];
              for (ext in extMap) {
                lan = extMap[ext];
                if (lan != null) {
                  try {
                    if (fs.existsSync(filePath + ext)) {
                      results1.push(install(conf, filePath + ext));
                    } else {
                      results1.push(void 0);
                    }
                  } catch (_error) {
                    e = _error;
                    results1.push(console.log(e));
                  }
                }
              }
              return results1;
            } else {
              return install(conf, filePath);
            }
          }
        })(filePath));
      }
      return results;
    }
  };

}).call(this);
