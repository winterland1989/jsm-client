// Generated by CoffeeScript 1.9.3
(function() {
  var CONFIG_FILE_NAME, DEFAULT_REPOSITORY, Promise, commentStartMap, configFile, extMap, fs, getExt, home, http, install, parseEntry, parseKeywords, parseRequires, path, querystring, url;

  path = require('path');

  http = require('http');

  querystring = require('querystring');

  url = require('url');

  fs = require('fs-extra');

  Promise = require('bluebird');

  CONFIG_FILE_NAME = '.jsm.json';

  DEFAULT_REPOSITORY = 'http://jsm.winterland.me';

  home = process.env[process.platform === 'win32' ? 'USERPROFILE' : 'HOME'];

  configFile = path.join(home, CONFIG_FILE_NAME);

  extMap = {
    '.ls': 'livescript',
    '.coffee': 'coffeescript',
    '.js': 'javascript'
  };

  commentStartMap = {
    'livescript': '#',
    'coffeescript': '#',
    'javascript': '//'
  };

  getExt = function(language) {
    var ext, lan;
    for (ext in extMap) {
      lan = extMap[ext];
      if (lan === language) {
        return ext;
      }
    }
    return '';
  };

  parseKeywords = function(content, language) {
    var i, keywordMark, keywords, len, line, ref;
    keywordMark = commentStartMap[language] + "-jsm-keywords:";
    ref = content.split('\n');
    for (i = 0, len = ref.length; i < len; i++) {
      line = ref[i];
      if ((line.indexOf(keywordMark)) === 0) {
        keywords = line.substr(keywordMark.length).split(' ');
        break;
      }
    }
    if (keywords == null) {
      keywords = [];
    }
    return keywords.filter(function(word) {
      return word.match(/\w+/g);
    });
  };

  parseRequires = function(content, language) {
    var requires;
    requires = [];
    switch (language) {
      case 'javascript':
        content.replace(/\brequire\s*\(\s*(["'])([^"'\s\)]+)\1\s*\)/g, function(match, quote, path) {
          requires.push(path);
          return match;
        });
        break;
      case 'coffeescript':
        content.replace(/\brequire\s*(["'])([^"'\s\)]+)\1\s*/g, function(match, quote, path) {
          requires.push(path);
          return match;
        });
        break;
      case 'livescript':
        content.replace(/\brequire[!?]\s*(["'])([^"'\s\)]+)\1\s*/g, function(match, quote, path) {
          requires.push(path);
          return match;
        });
    }
    return requires;
  };

  module.exports = {
    readJsmClientConfig: function() {
      var conf, f;
      if (fs.existsSync(configFile)) {
        f = fs.readFileSync(configFile, {
          encoding: 'utf8'
        });
        conf = JSON.parse(f);
        if (conf.repository) {
          return conf;
        } else {
          throw new Error("Parse config failed...");
        }
      } else {
        return {
          repository: DEFAULT_REPOSITORY
        };
      }
    },
    writeJsmClientConfig: function(conf) {
      var f;
      return f = fs.writeFileSync(configFile, JSON.stringify(conf), {
        encoding: 'utf8'
      });
    },
    parseEntry: parseEntry = function(filePath) {
      var author, authorMatch, base, dir, ext, title, titleMatch, version, versionMatch;
      filePath = path.normalize(filePath);
      ext = path.extname(filePath);
      base = path.basename(filePath, ext);
      dir = path.basename(path.dirname(filePath));
      titleMatch = base.match(/^([a-zA-Z]+)/g);
      title = (function() {
        if (titleMatch != null) {
          return titleMatch[0];
        } else {
          throw new Error("Parse entry name failed: " + filePath);
        }
      })();
      versionMatch = base.match(/([0-9]+)$/g);
      version = versionMatch != null ? parseInt(versionMatch[0]) : 0;
      authorMatch = dir.match(/^(\w+)$/g);
      author = authorMatch != null ? authorMatch[0] : void 0;
      return {
        title: title,
        version: version,
        author: author,
        language: ext === '' ? void 0 : extMap[ext]
      };
    },
    publish: function(conf, entry) {
      var checkRequires, hostname, port, ref;
      ref = url.parse(conf.repository), hostname = ref.hostname, port = ref.port;
      entry.keywords = JSON.stringify(parseKeywords(entry.content, entry.language));
      console.log("Entry keywords: " + entry.keywords);
      checkRequires = Promise.all((function() {
        var getData, i, index, len, ps, ref1, req, reqObj;
        ps = [];
        ref1 = parseRequires(entry.content, entry.language);
        for (i = 0, len = ref1.length; i < len; i++) {
          req = ref1[i];
          if ((index = req.indexOf('jsm')) !== -1) {
            reqObj = parseEntry(req.substr(index + 3));
            console.log("Checking " + reqObj.author + "/" + reqObj.title + "...");
            getData = querystring.stringify({
              title: reqObj.title,
              author: reqObj.author,
              version: reqObj.version
            });
            ps.push(new Promise(function(resolve, reject) {
              var chunks;
              chunks = [];
              req = http.request({
                hostname: hostname,
                port: port,
                path: '/snippet?' + getData,
                method: 'GET'
              }, function(res) {
                res.on('data', function(data) {
                  return chunks.push(data);
                });
                return res.on('end', function() {
                  var snippet;
                  snippet = JSON.parse(Buffer.concat(chunks).toString('utf8'));
                  return resolve(snippet.id);
                });
              });
              req.on('error', function(error) {
                reject(error);
                return console.log('Check failed with status: ' + res.statusCode);
              });
              return req.end();
            }));
          }
        }
        return ps;
      })());
      return checkRequires["catch"](function(e) {
        return console.log('Check requires failed...');
      }).then(function(ids) {
        var chunks, postData, req;
        console.log('Check requires finish...');
        entry.requires = JSON.stringify(ids);
        postData = querystring.stringify(entry);
        chunks = [];
        req = http.request({
          hostname: hostname,
          port: port,
          path: '/snippet',
          method: 'POST',
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            'Content-Length': postData.length
          }
        }, function(res) {
          res.on('data', function(data) {
            return chunks.push(data);
          });
          return res.on('end', function() {
            var snippet;
            if (res.statusCode === 200) {
              console.log('Publish finish with status: 200');
              snippet = JSON.parse(Buffer.concat(chunks).toString('utf8'));
              return console.log('Revision ' + snippet.revision + ' at ' + snippet.mtime);
            } else {
              return console.log('Publish failed with status: ' + res.statusCode);
            }
          });
        });
        req.on('error', function(error) {
          return console.log('Publish failed with status: ' + res.statusCode);
        });
        req.write(postData);
        return req.end();
      });
    },
    install: install = function(conf, target) {
      var entryContent, entryDir, filePath, i, language, len, requires, results;
      entryDir = path.dirname(target);
      entryContent = fs.readFileSync(target, 'utf8');
      requires = [];
      for (language in commentStartMap) {
        requires = parseRequires(entryContent, language);
        if (requires.length > 0) {
          break;
        }
      }
      results = [];
      for (i = 0, len = requires.length; i < len; i++) {
        filePath = requires[i];
        results.push((function(filePath) {
          var chunks, e, entryObj, ext, hostname, index, lan, port, ref, req, results1, succ;
          if ((index = filePath.indexOf('jsm')) !== -1) {
            entryObj = parseEntry(path.resolve(entryDir, filePath.substr(3)));
            filePath = path.resolve(entryDir, filePath);
            chunks = [];
            if ((entryObj.author != null) && (entryObj.title != null) && (entryObj.version != null)) {
              delete entryObj.language;
              ref = url.parse(conf.repository), hostname = ref.hostname, port = ref.port;
              req = http.request({
                hostname: hostname,
                port: port,
                path: '/snippet?' + querystring.stringify(entryObj),
                method: 'GET'
              }, function(res) {
                res.on('data', function(data) {
                  return chunks.push(data);
                });
                return res.on('end', function() {
                  var e, mtime, snippet;
                  if (res.statusCode === 200) {
                    try {
                      snippet = JSON.parse(Buffer.concat(chunks).toString('utf8'));
                      if ((path.extname(filePath)) === '') {
                        filePath += getExt(snippet.language);
                      }
                      fs.ensureFileSync(filePath);
                      fs.writeFileSync(filePath, snippet.content);
                      mtime = new Date(snippet.mtime);
                      fs.utimesSync(filePath, mtime, mtime);
                      install(conf, filePath);
                      return console.log("Installing snippet: " + filePath + " succeessfully");
                    } catch (_error) {
                      e = _error;
                      return console.log("Write snippet failed(" + e.message + "): " + filePath);
                    }
                  } else {
                    return console.log("Download snippet failed(status" + res.statusCode + "): " + filePath);
                  }
                });
              });
              req.on('error', function(e) {
                console.log("Get snippet failed(" + e.message + "): " + filePath);
                return console.log(error);
              });
              return req.end();
            } else {
              return console.log("Parse entry failed: " + filePath);
            }
          } else {
            filePath = path.resolve(entryDir, filePath);
            if ((path.extname(filePath)) === '') {
              succ = 0;
              results1 = [];
              for (ext in extMap) {
                lan = extMap[ext];
                if (lan != null) {
                  try {
                    if (fs.existsSync(filePath + ext)) {
                      results1.push(install(conf, filePath + ext));
                    } else {
                      results1.push(void 0);
                    }
                  } catch (_error) {
                    e = _error;
                    results1.push(console.log(e));
                  }
                }
              }
              return results1;
            } else {
              return install(conf, filePath);
            }
          }
        })(filePath));
      }
      return results;
    }
  };

}).call(this);
